{"version":3,"sources":["vp-pubsub.js"],"names":["vpPubsub","bootstrap","exports","module","define","amd","ses","ok","makeVPpubsub","window","VPpubsub","indexOf","arr","needed","i","max","length","isFunction","obj","api","subscribers","published","pub","evnt","data","scope","notAsync","addToPublished","scopeIndex","scopes","push","callAsync","sub","thisArg","originEvent","async","$$VPpubsubRemoved","call","evntPart","subs","validPublish","test","concat","split","x","xmax","subscriber","publish","index","orgEvent","RegExp","substr","replace","parseEvnt","pubIndex","isPublished","allEvnt","validSubscribe","slice","subonce","$$sub","unsub","eventSubs","splice","fork","process","next","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","nextTick","callback","setTimeout"],"mappings":"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","file":"vp-pubsub.js","sourcesContent":["/*Copyright 2014 Schuberg Philis\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n  http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n/* globals bootstrap, ses */\n(function (vpPubsub) {\n    /* jshint strict: false*/\n    // Montage Require\n    if (typeof bootstrap === 'function') {\n        bootstrap('promise', vpPubsub);\n    // CommonJS & nodejs\n    } else if (typeof exports === 'object') {\n        module.exports = vpPubsub();\n    // RequireJS\n    } else if (typeof define === 'function' && define.amd) {\n        define(vpPubsub);\n    // SES (Secure EcmaScript)\n    } else if (typeof ses !== 'undefined') {\n        if (!ses.ok()) {\n            return;\n        } else {\n            ses.makeVPpubsub = vpPubsub;\n        }\n    // <script>\n    } else {\n        window.VPpubsub = vpPubsub();\n    }\n})(function () {\n    /* jshint newcap: false */\n    'use strict';\n    var validSubscribe = /^!?(\\*$|[a-z])([a-z0-9]*)(\\.([a-z0-9]+|\\*$))*(@[0-9a-z]+)?$/,\n        validPublish = /^[a-z]([a-z0-9]*)(\\.[a-z0-9]+)*(@[0-9a-z]+)?$/,\n        async = (function () {\n            var api = typeof window === 'undefined' ? process : window,\n                next =  api.requestAnimationFrame  || api.webkitRequestAnimationFrame || api.mozRequestAnimationFrame || api.nextTick;\n            //browser\n            if (next) {\n                return next;\n            }\n            //fake async\n            return function (callback) {\n                setTimeout(callback, 1000 / 60);\n            };\n        }());\n    /**\n     * Array indexOf for IE8\n     * @param  {Array} arr\n     * @param  {*} needed\n     * @return {Number}\n     */\n    function indexOf(arr, needed) {\n        if (arr.indexOf) {\n            return arr.indexOf(needed);\n        }\n        for (var i = 0, max = arr.length; i < max; i++) {\n            if (arr[i] === needed) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    function isFunction (obj) {\n        return typeof obj === 'function';\n    }\n    /**\n     * VPpubsub module\n     */\n    function VPpubsub () {\n        var subscribers = {},\n            published = {},\n            api;\n        return (api = {\n            /**\n             * Publish a event\n             * @param  {string}     evnt                The event that you want to publish\n             * @param  {*}          [data]              Data that you want to send along with the event\n             * @param  {*}          [scope]             Event scope\n             * @param  {boolean}    [notAsync=false]    Events are default asynchronous, but in some cases yo don't want that\n             */\n            pub: function (evnt, data, scope, notAsync) {\n                var evntPart = '',\n                    subs = [],\n                    originEvent = evnt;\n                /**\n                 * Adds the event to published events\n                 * @param {String} evnt\n                 */\n                function addToPublished(evnt) {\n                    var scopeIndex;\n                    //add published\n                    if (!published[evnt]) {\n                        published[evnt] = {\n                            scopes:[],\n                            data: []\n                        };\n                    }\n                    //get event scope index\n                    scopeIndex = indexOf(published[evnt].scopes, scope);\n                    if (!~scopeIndex) {\n                        scopeIndex = published[evnt].scopes.push(scope) - 1;\n                    }\n                    //update / add last called data to event scope\n                    published[evnt].data[scopeIndex] = data;\n                }\n                function callAsync(sub, thisArg, data, originEvent) {\n                    async(function () {\n                        if (sub.$$VPpubsubRemoved !== originEvent) {\n                            sub.call(thisArg, data, originEvent, sub);\n                        }\n                    });\n                }\n                //is event valid\n                if (validPublish.test(evnt)) {\n                    //subscriber with id\n                    if (subscribers[evnt]) {\n                        subs = subs.concat(subscribers[evnt]);\n                    }\n                    //remove event\n                    evnt = evnt.split('@')[0];\n                    //subscriber without id\n                    if (evnt !== originEvent && subscribers[evnt]) {\n                        subs = subs.concat(subscribers[evnt]);\n                    }\n                    //add to published \n                    addToPublished(evnt);\n                    //wild card\n                    if (subscribers[evnt + '.*']) {\n                        subs = subs.concat(subscribers[evnt + '.*']);\n                    }\n                    //all other levels\n                    evnt = evnt.split('.');\n                    evntPart = evnt[0];\n                    for (var i = 1, max = evnt.length; i < max; i++) {\n                        if (subscribers[evntPart + '.*']) {\n                            subs = subs.concat(subscribers[evntPart + '.*']);\n                        }\n                        evntPart += '.' + evnt[i];\n                    }\n                    //all\n                    if (subscribers['*']) {\n                        subs = subs.concat(subscribers['*']);\n                    }\n                    //start publishing\n                    for (var x = 0, xmax = subs.length; x < xmax; x++) {\n                        if (!subs[x][1] || subs[x][1] === scope) {\n                            if (notAsync) {\n                                subs[x][0].call(subs[x][2], data, originEvent, subs[x][0]);\n                            } else {\n                                callAsync(subs[x][0], subs[x][2], data, originEvent);\n                            }\n                        }\n                    }\n                }\n            },\n            /**\n             * Subscribe to a event\n             * valid subscribe events\n             *     'x' or 'somelongname' or 'a123' the first character of a event must be a-z, a event must only contain only small characters or numbers\n             *     'x.x' you can use a '.' to name space the event\n             *     'x.*' you can use a '*' to subscribe to all events in a name space\n             *     '*' subscribe to all events\n             * invalid subscribe events\n             *     '1a' the first character can't be a number\n             *     'a.' name space can't be empty\n             *     'a#$' a event can't have other characters than a-z or 0-9\n             * Explanation mark \"!\" will republish the event to this subscriber if the event was already publish before\n             * @param {string}     evnt       The event where you want to subscribe\n             * @param {Function}   subscriber The subscriber to the events\n             * @param {*}          [scope]    Scope can be used to only subscribe to events that are in that scope\n             * @param {*}          [thisArg]  The `this` scope  of the subscriber\n             */\n            sub: function (evnt, subscriber, scope, thisArg) {\n                var allEvnt = evnt.split('|'),\n                    parseEvnt, pubIndex, isPublished;\n                /**\n                 * Publish event to current subscriber, if force publish is used\n                 * @param  {String} evnt [description]\n                 * @param  {Function} sub  [description]\n                 */\n                function publish (evnt, sub) {\n                    var index = -1,\n                        orgEvent = evnt;\n                    //if the sub don't have \n                    if (!~evnt.indexOf('*')) {\n                        //check of event already is published for this scope\n                        if (published[evnt]) {\n                            index = indexOf(published[evnt].scopes, scope);\n                        }\n                    } else {\n                        //rewrite event to regex\n                        evnt = new RegExp('^' +\n                                evnt.substr(0, evnt.length - 2)\n                                .replace('.', '\\\\.') +\n                                '(?![a-zA-Z0-9])');\n                        //find event based on regex\n                        for (orgEvent in published) {\n                            if (evnt.test(orgEvent)) {\n                                index = indexOf(published[orgEvent].scopes, scope);\n                                break;\n                            }\n                        }\n                    }\n                    //do we've found a event ?\n                    if (~index) {\n                        //call subscriber\n                        sub.call(thisArg, published[orgEvent].data[index], orgEvent, sub);\n                    }\n                }\n                //check of subscriber is a function\n                if (!isFunction(subscriber)) {\n                    return;\n                }\n                //loop though all events\n                for (var i = 0, max = allEvnt.length; i < max; i++) {\n                    parseEvnt = allEvnt[i];\n                    isPublished = false;\n                    if (validSubscribe.test(allEvnt[i])) {\n                        //fore publish if published to this subscriber\n                        if (parseEvnt.slice(0, 1) === '!') {\n                            parseEvnt = parseEvnt.slice(1);\n                            isPublished = true;\n                        }\n                        //add subscriber list\n                        if (!subscribers[parseEvnt]) {\n                            subscribers[parseEvnt] = [];\n                        }\n                        delete subscriber.$$VPpubsubRemoved;\n                        //add subscriber\n                        pubIndex = subscribers[parseEvnt].push([\n                            subscriber,\n                            scope,\n                            thisArg\n                        ]);\n                        //is published check\n                        if (isPublished) {\n                            publish(parseEvnt, subscribers[parseEvnt][pubIndex - 1][0]);\n                        }\n                    }\n                }\n            },\n            /**\n             * Subscribe once to an event\n             * @param  {String} evnt       you can't subscribe to a channel ( * )\n             * @param  {Function} subscriber\n             * @param  {*} scope\n             * @param  {*} thisArg\n             */\n            subonce: function (evnt, subscriber, scope, thisArg) {\n                //check of subscriber is a function\n                if (!isFunction(subscriber)) {\n                    return;\n                }\n                //you can't use *\n                if (!~evnt.indexOf('*')) {\n                    api.sub(evnt, function (data, evnt, $$sub) {\n                        api.unsub(evnt, $$sub, scope);\n                        subscriber.call(thisArg, data, evnt, subscriber);\n                    }, scope, thisArg);\n                }\n            },\n            /**\n             * Unsubscribe a subscriber from a event\n             * @param  {string}     evnt       Event where from you want to unsubscribe\n             * @param  {Function}   subscriber the subscriber\n             * @param  {*}          [scope]    the scope if used by subscribing\n             */\n            unsub: function (evnt, subscriber, scope) {\n                var eventSubs = subscribers[evnt] || [];\n                 //check of subscriber is a function\n                if (!isFunction(subscriber)) {\n                    return;\n                }\n                for (var i = 0, max  = eventSubs.length; i < max; i++) {\n                    if (eventSubs[i][0] === subscriber && (!eventSubs[i][1] || eventSubs[i][1] === scope)) {\n                        subscriber.$$VPpubsubRemoved = evnt;\n                        eventSubs.splice(i, 1);\n                        //index changed\n                        i--;\n                        max--;\n                    }\n                }\n            },\n            fork: function () {\n                return VPpubsub();\n            }\n        });\n    }\n    return VPpubsub();\n});"],"sourceRoot":"/source/"}